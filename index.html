<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Seaview Marina Tide Forecast</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body { font-family: sans-serif; background: #f0f8ff; margin: 20px; }
  h1 { text-align: center; color: #004080; }
  #chartContainer { width: 90%; max-width: 900px; margin: 30px auto; }
</style>
</head>
<body>

<h1>Seaview Marina Tide Forecast</h1>
<div id="chartContainer">
  <canvas id="tideChart"></canvas>
</div>

<script>
// 24-hour sample data
const forecasts = [
  {"time":"2025-11-18T00:00:00","height":1.2},
  {"time":"2025-11-18T01:00:00","height":1.4},
  {"time":"2025-11-18T02:00:00","height":1.6},
  {"time":"2025-11-18T03:00:00","height":1.8},
  {"time":"2025-11-18T04:00:00","height":1.7},
  {"time":"2025-11-18T05:00:00","height":1.5},
  {"time":"2025-11-18T06:00:00","height":1.3},
  {"time":"2025-11-18T07:00:00","height":1.2},
  {"time":"2025-11-18T08:00:00","height":1.4},
  {"time":"2025-11-18T09:00:00","height":1.6},
  {"time":"2025-11-18T10:00:00","height":1.9},
  {"time":"2025-11-18T11:00:00","height":2.1},
  {"time":"2025-11-18T12:00:00","height":2.0},
  {"time":"2025-11-18T13:00:00","height":1.8},
  {"time":"2025-11-18T14:00:00","height":1.6},
  {"time":"2025-11-18T15:00:00","height":1.5},
  {"time":"2025-11-18T16:00:00","height":1.4},
  {"time":"2025-11-18T17:00:00","height":1.3},
  {"time":"2025-11-18T18:00:00","height":1.2},
  {"time":"2025-11-18T19:00:00","height":1.3},
  {"time":"2025-11-18T20:00:00","height":1.5},
  {"time":"2025-11-18T21:00:00","height":1.7},
  {"time":"2025-11-18T22:00:00","height":1.6},
  {"time":"2025-11-18T23:00:00","height":1.4}
];

// Process time, labels, find current hour
function processData(forecasts) {
  const labels = [];
  const heights = [];
  const now = new Date();
  let currentIndex = 0;

  forecasts.forEach((f, i) => {
    const t = new Date(f.time);
    labels.push(t.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}));
    heights.push(f.height);
    if (t > now && currentIndex === 0) currentIndex = i;
  });

  return { labels, heights, currentIndex };
}

let dragIndex = null;        // the index used during drag
let isDragging = false;      // dragging state

function drawCustomTooltip(chart, index, heights) {
  const ctx = chart.ctx;
  const x = chart.scales.x.getPixelForValue(index);
  const y = chart.scales.y.getPixelForValue(heights[index]);

  const rising = heights[index+1] > heights[index] ? "Rising" :
                 heights[index+1] < heights[index] ? "Falling" : "Steady";

  const text = `${heights[index].toFixed(2)} m (${rising})`;

  ctx.save();
  ctx.fillStyle = "white";
  ctx.strokeStyle = "black";
  ctx.lineWidth = 1;

  // Tooltip box
  ctx.beginPath();
  ctx.rect(x + 10, y - 20, ctx.measureText(text).width + 12, 20);
  ctx.fill();
  ctx.stroke();

  // Text
  ctx.fillStyle = "black";
  ctx.fillText(text, x + 16, y - 6);

  ctx.restore();
}

function drawChart(labels, heights, currentIndex) {
  const ctx = document.getElementById('tideChart').getContext('2d');

  const tideChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [{
        label: 'Tide Height (m)',
        data: heights,
        fill: true,
        borderColor: '#007bff',
        backgroundColor: 'rgba(0,123,255,0.2)',
        tension: 0.3,
        pointRadius: 3
      }]
    },
    options: {
      responsive: true,
      animation: false,
      plugins: { tooltip: { enabled: false }, legend: { display: false } },
      scales: {
        x: { title: { display: true, text: 'Time' } },
        y: {
          title: { display: true, text: 'Height (m)' },
          suggestedMin: Math.min(...heights)-0.5,
          suggestedMax: Math.max(...heights)+0.5
        }
      }
    }
  });

  const canvas = tideChart.canvas;
  const rect = canvas.getBoundingClientRect();

  // Draw everything including tooltip + red line
  function redraw() {
    tideChart.update();

    const index = isDragging ? dragIndex : currentIndex;
    const xPixel = tideChart.scales.x.getPixelForValue(index);

    const ctx2 = tideChart.ctx;
    ctx2.save();
    ctx2.beginPath();
    ctx2.moveTo(xPixel, tideChart.scales.y.top);
    ctx2.lineTo(xPixel, tideChart.scales.y.bottom);
    ctx2.strokeStyle = 'red';
    ctx2.lineWidth = 2;
    ctx2.stroke();
    ctx2.restore();

    drawCustomTooltip(tideChart, index, heights);
  }

  redraw();
  tideChart.options.animation = false;

  // Dragging behaviour
  canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!isDragging) return;

    const x = e.clientX - rect.left;
    let nearest = tideChart.scales.x.getValueForPixel(x);

    nearest = Math.round(nearest);
    nearest = Math.max(0, Math.min(nearest, heights.length - 1));

    dragIndex = nearest;
    redraw();
  });

  canvas.addEventListener('mouseup', () => {
    isDragging = false;
    redraw(); // return to currentIndex
  });

  canvas.addEventListener('mouseleave', () => {
    isDragging = false;
    redraw(); // return
  });
}

const { labels, heights, currentIndex } = processData(forecasts);
drawChart(labels, heights, currentIndex);

</script>

</body>
</html>
