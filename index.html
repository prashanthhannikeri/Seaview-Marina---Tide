<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Seaview Marina Tide Forecast</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<style>
  body { font-family:sans-serif; background:#f0f8ff; margin:20px; }
  h1 { text-align:center; color:#004080; }
  #chartWrap { width:90%; max-width:900px; margin:auto; position:relative; }
  canvas { background:#fff; border-radius:6px; display:block; height:400px; width:100%; }
  .tooltip-box {
    position:absolute; pointer-events:none; background:rgba(0,0,0,0.8);
    color:#fff; padding:6px 10px; border-radius:6px; font-size:13px; display:none;
    transform:translate(-50%, -100%);
  }
  table { width:90%; max-width:900px; margin:20px auto; border-collapse:collapse; }
  th, td { padding:6px; border-bottom:1px solid #eee; text-align:center; }
  th { background:#f7fbff; color:#004080; }
  .highlight { background:rgba(255,0,0,0.2); font-weight:600; }
</style>
</head>
<body>

<h1>Seaview Marina Tide Forecast</h1>
<div id="chartWrap">
  <canvas id="tideChart"></canvas>
  <div id="lineTooltip" class="tooltip-box"></div>
</div>
<table id="tideTable">
  <thead><tr><th>Time</th><th>Height (m)</th><th>Trend</th></tr></thead>
  <tbody></tbody>
</table>

<script>
// Sample 24h tide data
const forecasts = [
  {"time":"2025-11-18T00:00:00","height":1.2},{"time":"2025-11-18T01:00:00","height":1.4},
  {"time":"2025-11-18T02:00:00","height":1.6},{"time":"2025-11-18T03:00:00","height":1.8},
  {"time":"2025-11-18T04:00:00","height":1.7},{"time":"2025-11-18T05:00:00","height":1.5},
  {"time":"2025-11-18T06:00:00","height":1.3},{"time":"2025-11-18T07:00:00","height":1.2},
  {"time":"2025-11-18T08:00:00","height":1.4},{"time":"2025-11-18T09:00:00","height":1.6},
  {"time":"2025-11-18T10:00:00","height":1.9},{"time":"2025-11-18T11:00:00","height":2.1},
  {"time":"2025-11-18T12:00:00","height":2.0},{"time":"2025-11-18T13:00:00","height":1.8},
  {"time":"2025-11-18T14:00:00","height":1.6},{"time":"2025-11-18T15:00:00","height":1.5},
  {"time":"2025-11-18T16:00:00","height":1.4},{"time":"2025-11-18T17:00:00","height":1.3},
  {"time":"2025-11-18T18:00:00","height":1.2},{"time":"2025-11-18T19:00:00","height":1.3},
  {"time":"2025-11-18T20:00:00","height":1.5},{"time":"2025-11-18T21:00:00","height":1.7},
  {"time":"2025-11-18T22:00:00","height":1.6},{"time":"2025-11-18T23:00:00","height":1.4}
];

const dataPoints = forecasts.map(f=>({x:new Date(f.time),y:f.height}));
const tooltip = document.getElementById('lineTooltip');
const tbody = document.querySelector('#tideTable tbody');
let markerTime = new Date();
let isDragging = false;

// Linear interpolation with slope
function sampleAt(timeMs){
  if(timeMs <= +dataPoints[0].x) return {x:dataPoints[0].x,y:dataPoints[0].y,slope:dataPoints[1].y-dataPoints[0].y};
  if(timeMs >= +dataPoints[dataPoints.length-1].x) return {x:dataPoints[dataPoints.length-1].x,y:dataPoints[dataPoints.length-1].y,slope:dataPoints[dataPoints.length-1].y-dataPoints[dataPoints.length-2].y};
  for(let i=0;i<dataPoints.length-1;i++){
    const t0 = +dataPoints[i].x, t1 = +dataPoints[i+1].x;
    if(timeMs >= t0 && timeMs <= t1){
      const ratio = (timeMs-t0)/(t1-t0);
      const y = dataPoints[i].y + (dataPoints[i+1].y - dataPoints[i].y)*ratio;
      const slope = (dataPoints[i+1].y - dataPoints[i].y)/((t1-t0)/3600000);
      return {x:new Date(timeMs),y,slope};
    }
  }
  return {x:dataPoints[dataPoints.length-1].x,y:dataPoints[dataPoints.length-1].y,slope:0};
}

// Find high/low tide points
function findHighLow(data){
  const result = [];
  for(let i=1;i<data.length-1;i++){
    if(data[i].y>data[i-1].y && data[i].y>data[i+1].y) result.push({...data[i],type:'high'});
    else if(data[i].y<data[i-1].y && data[i].y<data[i+1].y) result.push({...data[i],type:'low'});
  }
  return result;
}
const highLowPoints = findHighLow(dataPoints);

// Build table showing only high/low in trend
dataPoints.forEach(dp=>{
  const t = dp.x.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  const trendPoint = highLowPoints.find(p=>+p.x===+dp.x);
  const trendText = trendPoint ? (trendPoint.type==='high'?'High':'Low') : '';
  tbody.innerHTML += `<tr><td>${t}</td><td>${dp.y.toFixed(2)}</td><td class="trend">${trendText}</td></tr>`;
});

// Vertical line plugin with high/low markers
const verticalLinePlugin = {
  id:'verticalLinePlugin',
  afterDraw(chart){
    const xScale = chart.scales.x, yScale = chart.scales.y;
    if(!xScale||!yScale) return;
    const ctx = chart.ctx;
    const x = xScale.getPixelForValue(markerTime);

    // Red vertical line
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x,yScale.top);
    ctx.lineTo(x,yScale.bottom);
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Red circle at marker
    const s = sampleAt(+markerTime);
    const y = yScale.getPixelForValue(s.y);
    ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2); ctx.fill();

    // High/low tide markers
    highLowPoints.forEach(p=>{
      const px = xScale.getPixelForValue(p.x);
      const py = yScale.getPixelForValue(p.y);
      ctx.fillStyle = (p.type==='high')?'green':'orange';
      ctx.beginPath(); ctx.arc(px,py,6,0,Math.PI*2); ctx.fill();
      ctx.font='12px sans-serif';
      ctx.fillStyle='#000';
      ctx.textAlign='center';
      ctx.fillText(p.type==='high'?'High':'Low', px, py-10);
    });
    ctx.restore();

    // Tooltip close to line
    tooltip.style.display='block';
    tooltip.innerHTML=`<strong>${s.x.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}</strong><br>${s.y.toFixed(2)} m`;
    tooltip.style.left = x + 'px';
    tooltip.style.top = y - 35 + 'px';

    // Highlight table row
    const rows = tbody.querySelectorAll('tr');
    rows.forEach(r=>r.classList.remove('highlight'));
    let closestIndex = 0;
    let minDiff = Infinity;
    dataPoints.forEach((dp,i)=>{
      const diff = Math.abs(+dp.x - +markerTime);
      if(diff<minDiff){ minDiff=diff; closestIndex=i; }
    });
    rows[closestIndex].classList.add('highlight');
  }
};

// Chart
const ctx = document.getElementById('tideChart').getContext('2d');
const chart = new Chart(ctx,{
  type:'line',
  data:{datasets:[{
    label:'Tide Height (m)',
    data:dataPoints,
    borderColor:'#007bff',
    backgroundColor:'rgba(0,123,255,0.2)',
    tension:0.3,
    fill:true,
    pointRadius:3
  }]},
  options:{
    responsive:true,
    maintainAspectRatio:false,
    scales:{
      x:{type:'time', time:{unit:'hour', tooltipFormat:'HH:mm'}, title:{display:true,text:'Time'}},
      y:{title:{display:true,text:'Height (m)'}}
    },
    plugins:{legend:{display:false}, tooltip:{enabled:false}}
  },
  plugins:[verticalLinePlugin]
});

// Drag logic
const canvas = chart.canvas;
function pixelToTime(px){ return chart.scales.x.getValueForPixel(px); }

canvas.addEventListener('mousedown', e=>{isDragging=true; markerTime=pixelToTime(e.offsetX); chart.draw();});
canvas.addEventListener('mousemove', e=>{if(isDragging){markerTime=pixelToTime(e.offsetX); chart.draw();}});
canvas.addEventListener('mouseup', e=>{
  if(isDragging){
    isDragging=false;
    const start = +markerTime;
    const end = +new Date();
    const t0 = performance.now();
    function step(now){
      const elapsed = now-t0;
      const frac = Math.min(1, elapsed/800);
      const ease = 1-(1-frac)*(1-frac);
      markerTime = new Date(start + (end-start)*ease);
      chart.draw();
      if(frac<1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }
});

// Auto-update every minute
setInterval(()=>{if(!isDragging) markerTime=new Date(); chart.draw();},60000);

markerTime = new Date(); chart.draw();
</script>
</body>
</html>
